// Generated by CoffeeScript 1.12.7
(function() {
  var SignalR, SignalRNodeWrapper, SignalRRegistry, iSignalRWrapper,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  SignalR = require('signalr-client');

  iSignalRWrapper = require('../helpers/iSignalRWrapper');

  SignalRRegistry = require('../interfaces/SignalRRegistry');

  module.exports = SignalRNodeWrapper = (function(superClass) {
    var registry;

    extend(SignalRNodeWrapper, superClass);

    registry = new SignalRRegistry();

    function SignalRNodeWrapper(url, hubNames1, options) {
      this.url = url;
      this.hubNames = hubNames1;
      this.options = options != null ? options : {};
      this.available_hubs = hubNames;
      this.signalr = null;
      SignalRNodeWrapper.__super__.constructor.call(this);
    }

    SignalRNodeWrapper.prototype.getHub = function(which, callback, retries) {
      var _this, hub, retry;
      if (retries == null) {
        retries = 10;
      }
      if (this.signalr == null) {
        this.signalr = new SignalR.client(this.url, this.available_hubs, null);
      }
      hub = registry.hubs[which];
      if (hub != null) {
        return callback(null, hub);
      }
      if (hub === this.signalr.hub(which)) {
        hub.on('error', function(data) {
          return log(data);
        });
        hub.on('UpdateEntity', registry.observer_registry);
        return callback(null, hub);
      } else if (retries-- > 0) {
        _this = this;
        retry = function() {
          return _this.getHub(which, callback, retries);
        };
        return setTimeout(retry, 1000);
      } else {
        return callback("Timed out.", null);
      }
    };

    SignalRNodeWrapper.prototype.subscribe = function(hubName, method, observerId, subject, futureCallback, callback) {
      registry.setCallback(subject, futureCallback);
      return this.getHub(hubName, function(error, hub) {
        if (error != null) {
          return callback(error, null);
        } else {
          if (hub != null) {
            hub.invoke(method, observerId);
          }
          return callback(null, hub);
        }
      });
    };

    SignalRNodeWrapper.prototype.unsubscribe = function(hubName, method, observerId, subject, pastCallback, callback) {
      registry.removeCallback(subject, pastCallback);
      if (registry.observer_callbacks[subject].length === 0) {
        return this.getHub(hubName, function(error, hub) {
          if (error != null) {
            return callback(error, null);
          } else {
            if (hub != null) {
              hub.invoke(method, observerId);
            }
            return callback(null, hub);
          }
        });
      } else {
        return callback(null, true);
      }
    };

    return SignalRNodeWrapper;

  })(iSignalRWrapper);

}).call(this);

//# sourceMappingURL=SignalRWrapper.js.map
