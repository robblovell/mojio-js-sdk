// Generated by CoffeeScript 2.0.2
(function() {
  // assume's JQuery javascript client (bower install jquery).
  var SignalRBrowserWrapper, SignalRRegistry, iSignalRWrapper;

  iSignalRWrapper = require('./iSignalRWrapper');

  SignalRRegistry = require('./SignalRRegistry');

  module.exports = SignalRBrowserWrapper = (function() {
    var registry;

    class SignalRBrowserWrapper extends iSignalRWrapper {
      constructor(url, hubNames1, jquery) { // hubNames not used.
        super();
        this.url = url;
        this.hubNames = hubNames1;
        this.$ = jquery;
        this.available_hubs = hubNames;
        this.signalr = null;
        this.connectionStatus = false;
      }

      getHub(which, callback) {
        var hub;
        if (registry.hubs[which]) {
          return callback(null, registry.hubs[which]);
        } else {
          if (this.signalr == null) {
            this.signalr = this.$.hubConnection(this.url, {
              useDefaultPath: false
            });
            this.signalr.error(function(error) {
              console.log("Connection error" + error);
              return callback(error, null);
            });
          }
          registry.hubs[which] = this.signalr.createHubProxy(which);
          hub = registry.hubs[which];
          hub.on("error", function(data) {
            return console.log("Hub '" + which + "' has error" + data);
          });
          hub.on("UpdateEntity", registry.observer_registry);
          if (hub.connection.stateMachine !== 1) {
            if (!this.connectionStatus) {
              return this.signalr.start().done(() => {
                this.connectionStatus = true;
                return hub.connection.start().done(() => {
                  return callback(null, hub);
                });
              });
            } else {
              return hub.connection.start().done(() => {
                return callback(null, hub);
              });
            }
          } else {
            return callback(null, hub);
          }
        }
      }

      subscribe(hubName, method, observerId, subject, futureCallback, callback) {
        registry.setCallback(subject, futureCallback);
        return this.getHub(hubName, function(error, hub) {
          if (error != null) {
            return callback(error, null);
          } else {
            if (hub != null) {
              hub.invoke(method, observerId);
            }
            return callback(null, hub);
          }
        });
      }

      unsubscribe(hubName, method, observerId, subject, pastCallback, callback) {
        registry.removeCallback(subject, pastCallback);
        if (registry.observer_callbacks[subject].length === 0) {
          return this.getHub(hubName, function(error, hub) {
            if (error != null) {
              return callback(error, null);
            } else {
              if (hub != null) {
                hub.invoke(method, observerId);
              }
              return callback(null, hub);
            }
          });
        } else {
          return callback(null, true);
        }
      }

    };

    registry = new SignalRRegistry();

    return SignalRBrowserWrapper;

  })();

}).call(this);

//# sourceMappingURL=SignalRWrapper.js.map
